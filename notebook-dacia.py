# -*- coding: utf-8 -*-
"""Dacia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_4Rb1K5xfjC3NDt0h0P0x_oLg-681A18
"""

# prompt: read  a csv file from a github repot and populate a dataframe with it

import pandas as pd
from datetime import datetime

# Replace with your actual GitHub raw CSV file URL
url = 'https://raw.githubusercontent.com/aaldescu/dacia-auto-kleinanzeigen/refs/heads/main/cars_clean.csv'

try:
    df = pd.read_csv(url)
    print(df.head())  # Print the first few rows of the DataFrame
except Exception as e:
    print(f"An error occurred: {e}")

print(df.columns)
print(df.dtypes)

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import CountVectorizer
import pandas as pd
import numpy as np

# Filtrare mașini second-hand
df_model = df[df['posted_today'] == 'No'][['price', 'km', 'car_year', 'model', 'time_on_market', 'zipcode', 'title']].copy()

print(len(df_model))

# ***DIAGNOSE INFINITE VALUES***
# Check for infinite values and replace them with NaN
df_model.replace([np.inf, -np.inf], np.nan, inplace=True)
df_model = df_model.fillna(1)  # fill NaN values

# ***AVOID DIVISION BY ZERO***
# Replace 0 values in 'km' and 'age' with a small positive value (e.g., 1) to avoid division by zero
df_model['km'] = df_model['km'].replace(0, 1)



print(len(df_model))

# Separare X și y
X = df_model.drop(columns=['price'])
y = df_model['price']

'''
# Coloane categorice (de transformat cu OneHotEncoder)
categorical_cols = ['model', 'zipcode']
numeric_cols = [col for col in X.columns if col not in categorical_cols]

# Pipeline pentru preprocesare + model
preprocessor = ColumnTransformer([
    ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_cols)
], remainder='passthrough')

model = Pipeline([
    ('prep', preprocessor),
    ('reg', RandomForestRegressor(n_estimators=100, random_state=42))
])
'''

# Coloane
categorical_cols = ['model', 'zipcode']
text_col = 'title'
numeric_cols = ['km', 'car_year', 'time_on_market', 'age', 'price_per_km', 'price_per_year']

# Prelucrator pentru titlu
text_transformer = CountVectorizer(max_features=100)

# ColumnTransformer
preprocessor = ColumnTransformer(transformers=[
    ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_cols),
    ('text', Pipeline([('vect', text_transformer)]), text_col)
], remainder='passthrough')

# Pipeline final
model = Pipeline([
    ('prep', preprocessor),
    ('reg', RandomForestRegressor(n_estimators=100, random_state=42))
])


# Antrenare model
model.fit(X, y)

df_new = df[df['posted_today'] == 'Yes'][['km', 'car_year', 'model', 'time_on_market', 'zipcode','title']].copy()

print (len(df_new) )

df_new.head()

# Filtrare rânduri adăugate azi
df_new['time_on_market'] = df_new['time_on_market'].fillna(0)

df_new = df_new.dropna()

print (len(df_new) )

df_new.head()

# Pregătire coloane
X_new = df_new[['km', 'car_year', 'model', 'time_on_market', 'zipcode','title']]

# Estimare preț
df_new['predicted_price'] = model.predict(X_new)

df_new

# prompt: bring into df_new all other columns from the df


# Get additional columns from the original dataframe
other_columns = ['id', 'price', 'title', 'location']
temp_df = df[df['posted_today'] == 'Yes'][other_columns].copy()

# Concatenate df_new with temp_df along the columns (axis=1)
df_new = pd.concat([df_new, temp_df], axis=1)

df_new

# prompt: find the best deals in df_new , use ge predicted price , the price  which is the actual asking price

# Calculate the difference between the predicted price and the actual price
df_new['price_difference'] = df_new['predicted_price'] - df_new['price']

# Find the best deals (where the predicted price is significantly lower than the actual price)
best_deals = df_new.sort_values(by='price_difference', ascending=True)[['title','km', 'car_year','zipcode','id','predicted_price','price_difference','price',]]

# Display the best deals
best_deals

# prompt: prin an interactive table of the best_deals dataframe , and have the id column clickable  with href =https://www.kleinanzeigen.de/s-anzeige/{id}

import pandas as pd

# Assuming 'best_deals' DataFrame is already created as in your previous code

# Create the HTML table with clickable IDs
html_table = best_deals.to_html(escape=False, formatters=dict(id=lambda id: f'<a href="https://www.kleinanzeigen.de/s-anzeige/{id}" target="_blank">{id}</a>'))

# Display the HTML table
from IPython.display import HTML
HTML(html_table)